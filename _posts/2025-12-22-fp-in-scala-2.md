---
author: yuta
title: Functional Programming in Scala - Day 2
date: 2025-12-22 -0800
categories: [FunctionalProgramming, FpInScala]
tags: []
---

> Read from start of Section 2.5 to section 2.5.1

## Notes
### 2.5 Polymorphic functions: abstracting over types
- Up until this point, the book only talked about *monomorphic* functions, which are functions that operate on only one type of data.
- This section introduces *polymorphic functions*. 
  - These are functions that would work for *any* type that is given.
  - The notion of "polymorphism" is used in a slightly different meaning from OOP here. This form of polymorphism is sometimes called *parametric polymorphism*.
- For example, the functions `abs` and `factorial` that we saw in the previous section  are specific to arguments of type `Int`.
- Even the HOF `formatResult` is fixed to operate on functions that take arguments of type `Int`.

#### 2.5.1 An example of a polymorphic function
- Polymorphic functions can be discovered by observing several monomorphic functions.
  - I mean, I have also felt this but I feel like there are several functions that can behave similarly, but not close enough so that you'd actually be able to create a polymorphic function out of them...
  - This also seems to be the difficult part of programming - finding abstractions.
    - I feel like this can also go very wrong when you find the incorrect abstraction.
    - I wonder if you can actually make something so abstract that changing it becomes a monumental task?
- Below is an example of a monomorphic function that finds a `String` in an array.
  - ```scala
    def findFirst(ss: Array[String], key: String): Int = {
      @annotation.tailrec
      def loop(n: Int): Int =
        if (n >= ss.length) -1
        else if (ss(n) == key) n
        else loop(n+1)

      loop(0)
    }
    ```
  - This function is specialized for searching for a `String` in an `Array` of `String` values.
    - This sort of specialization for `String` types is what makes it a "monomorphic" function.
- The important thing to realize that if you replace the type `String` in the monomorphic `findFirst` method with some generic type, then the method still has the same functionality.
- Below is the polymorphic version of `findFirst`.
  - ```scala
    // Everything within the "[]" after the method name are the type parameters. So in this case "A" is a type parameter.
    // You may call the type parameters anything you want. It is completely syntactically correct to replace "A" with say, "BEEPBOOP"
    def findFirst[A](as: Array[A], p: A => Boolean): Int = {
      @annotation.tailrec
      def loop(n: Int): Int = 
        if (n >= as.length) -1
        else if (p(as(n))) n
        else loop(n+1)

      loop(0)
    }
    ```
  - This is an example of a polymorphic function, sometimes called a *generic* function.
  - Notice how this is *abstracting over the type* of the array and the function used for searching in it.
  - The type parameter list introduces *type variables* that can be referenced in the rest of the type signature.
- This exercise of turning monomorphic functions into polymorphic functions reminds me of the LazyArray problem, where you can continuously add maps.
  - I wonder if Scala would actually be a good tool for writing the code for that.

##### Exercise 2.2
- Implement `isSorted`, which checks whether an `Array[A]` is sorted according to a given comparison function.
- The method signature must be `def isSorted[A](as: Array[A], ordered: (A,A) => Boolean): Boolean`
